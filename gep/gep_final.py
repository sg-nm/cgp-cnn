import numpy as np
from utils import *

POPULATION_SIZE = 50
GENE_LENGTH = 11
MAX_GEN = 10
MUTATION_PROB = 0.1


#Function fitness defines the fitness value of the state: Total number of pairs of queens is 8C2 = 28
def fitness(gene):
	
	return fitness

'''
	Function reproduce takes in two parent states and generates a random child
	We first choose a random crossover point in the state (there are 9 possibilities for this: 0 through 8 including both)
	The child is generated by appending the first end of parent1 until the crossover point and second end of parent2
'''

def reproduce(parent1, parent2, GENE_LENGTH):
	c = np.random.randint(0,GENE_LENGTH+1)
	child = parent1.copy()
	child[c:] = parent2[c:]
	return child

'''
	Function mutate takes in a state, a mutation probability
	for each position of the state, we choose a random value with probability mutation_prob
'''

def mutate(gene, MUTATION_PROB, GENE_LENGTH):
	mutated_gene = gene.copy()
	for i in range(GENE_LENGTH):
		random_gen = np.random.uniform()
		if (random_gen < MUTATION_PROB):
			mutated_gene[i] = 1 - mutated_gene[i]
	return mutated_gene

'''
	Function genetic_run executes a single run of the genetic algorithm
	It takes in the population size, number of iterations, mutation probability
	We first populate the population randomly
	We also maintain a variable h_opt that keeps track of the minimum heuristic value across all individuals seen so far
	In each iteration, we evaluate the fitness of the current population and define the selection probability by normalizing
	We select two parents at random using this probability distribution and then generate a child and perform mutation
	The population is then updated to consist of these children
	At the end of all iterations, we return the optimal value h* we have seen across all individuals
'''

def genetic_run(MAX_GEN, POPULATION_SIZE, GENE_LENGTH, MUTATION_PROB):
	population = []
	for i in range(POPULATION_SIZE):
		random_gene = np.random.randint(2, size=GENE_LENGTH)
		population.append(random_gene)
	opt_fitness = fitness(population[0])
	opt_gene = population[0]
	for i in range(1,POPULATION_SIZE):
		current_gene = population[i]
		current_fitness = fitness(current_gene)
		if (current_fitness > opt_fitness):
			opt_fitness = current_fitness
			opt_gene = current_gene
	for _ in range(MAX_GEN):
		new_population = []
		population_fitness = [fitness(gene) for gene in population]
		selection_probability = population_fitness / np.sum(population_fitness)
		for j in range(population_size):
			indices = np.random.choice(POPULATION_SIZE,2,p=selection_probability)
			parent1 = population[indices[0]]
			parent2 = population[indices[1]]
			child = reproduce(parent1,parent2, GENE_LENGTH)
			child = mutate(child, MUTATION_PROB, GENE_LENGTH)
			new_population.append(child)
		population = new_population
		for i in range(population_size):
			current_gene = population[i]
			current_fitness = fitness(current_gene)
			if (current_fitness > opt_fitness):
				opt_fitness = current_fitness
				opt_gene = current_gene
	return opt_fitness, opt_gene

'''
	Function genetic takes in population size, number of iterations, mutation probability, and number of runs
	We use the output of each run to compute an empirical estimate of h*
'''

def genetic(population_size, num_iter, mutation_prob, num_runs):
	h_sum = 0
	for i in range(num_runs):
		if (i%100 == 0):
			print(f"{i} runs completed")
		np.random.seed(i)
		h_sum += genetic_run(population_size, num_iter, mutation_prob)
	print(f"Empirical estimate of h*: {h_sum/num_runs}")

genetic(4, 100, 0.1, 10000)